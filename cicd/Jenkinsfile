// =========================================================================
// SECTION 1: PIPELINE PROPERTIES
// =========================================================================
properties([
    parameters([
        string(name: 'USERNAME', defaultValue: '...', description: 'Jira username'),
        password(name: 'PASSWORD', defaultValue: '', description: 'Jira password'),
        choice(
            name: 'SOURCE_TYPE',
            choices: ['group', 'project', 'users', 'sprint', 'jql'],
            description: 'The source for finding users to report on.'
        ),
        string(
            name: 'SOURCE_IDENTIFIER',
            defaultValue: 'developers',
            description: 'The name of the group, project key, or comma-separated list of usernames.'
        ),
        booleanParam(
            name: 'LATEST_SPRINT',
            defaultValue: false,
            description: 'Check this to generate the report for each user\'s individual latest completed sprint.'
        ),
        string(
            name: 'START_DATE',
            defaultValue: '',
            description: 'Start date (YYYY-MM-DD). Leave empty if using --latest-sprint without date override.'
        ),
        string(
            name: 'END_DATE',
            defaultValue: '',
            description: 'End date (YYYY-MM-DD). Leave empty if using --latest-sprint without date override.'
        ),
        string(
            name: 'REPORT_OUTPUT',
            defaultValue: 'performance_report.xlsx',
            description: 'The name of the output report file.'
        )
        
    ])
])

// =========================================================================
// SECTION 2: PIPELINE EXECUTION
// =========================================================================
node {
    def CONFIG = [
        VENV_DIR: 'venv',
        PYTHON_EXECUTABLE: isUnix() ? 'python3' : 'py -3',
        REPORT_FILE_NAMES: [
            'final_report': params.REPORT_OUTPUT || 'performance_report.xlsx',
            'running_log': 'app.log'
        ]
    ]
    
    try {
        stage('Set Build Name') {
            configureBuildInfo()
        }

        stage('Setup Environment') {
            setupPythonEnvironment(CONFIG.VENV_DIR, CONFIG.PYTHON_EXECUTABLE)
        }

        stage('Run Performance Reporter') {
            runPerformanceReport(CONFIG.VENV_DIR)
        }

        stage('Archive Report') {
            archiveReportArtifacts(CONFIG.REPORT_FILE_NAMES)
        }
    }
    catch (Exception e) {
        handleError(e)
    }
    finally {
        cleanup(CONFIG.VENV_DIR)
    }
}

// =========================================================================
// SECTION 3: BUILD CONFIGURATION FUNCTIONS
// =========================================================================
def configureBuildInfo() {
    def builderName = getBuilderName()
    def buildName = constructBuildName(builderName)
    def buildDescription = constructBuildDescription(builderName)
    
    currentBuild.displayName = buildName
    currentBuild.description = buildDescription
    echo "Set build name to: ${buildName}"
}

def getBuilderName() {
    def cause = currentBuild.getBuildCauses('hudson.model.Cause$UserIdCause')
    return cause.userName ?: 'Scheduler'
}

def constructBuildName(builderName) {
    def name = "[${builderName}] ${params.SOURCE_TYPE}: ${params.SOURCE_IDENTIFIER}"
    if (params.LATEST_SPRINT) {
        name += " @latest"
    }
    name += " (${params.REPORT_FORMAT ?: 'excel'})"
    return name
}

def constructBuildDescription(builderName) {
    def description = "Triggered by: **${builderName}**\n\n"
    description += "Report for ${params.SOURCE_TYPE} '${params.SOURCE_IDENTIFIER}'"
    
    if (params.START_DATE && params.END_DATE) {
        description += " from ${params.START_DATE} to ${params.END_DATE}."
    } else if (params.START_DATE) {
        description += " starting from ${params.START_DATE}."
    } else if (params.END_DATE) {
        description += " until ${params.END_DATE}."
    } else if (params.LATEST_SPRINT) {
        description += " for the latest completed sprint."
    }
    
    return description
}

// =========================================================================
// SECTION 4: ENVIRONMENT SETUP FUNCTIONS
// =========================================================================
def setupPythonEnvironment(venvDir, pythonExecutable) {
    echo "Setting up Python virtual environment..."
    checkout scm
    
    if (isUnix()) {
        setupUnixEnvironment(venvDir, pythonExecutable)
    } else {
        setupWindowsEnvironment(venvDir, pythonExecutable)
    }
}

def setupUnixEnvironment(venvDir, pythonExecutable) {
    def venvActivate = ". ${venvDir}/bin/activate"
    sh """
        ${pythonExecutable} --version
        rm -rf ${venvDir}
        ${pythonExecutable} -m venv ${venvDir}
        ${venvActivate} && pip install --upgrade pip && pip install -r requirements.txt
    """
}

def setupWindowsEnvironment(venvDir, pythonExecutable) {
    def venvActivate = "${venvDir}\\Scripts\\activate"
    bat """
        ${pythonExecutable} --version
        rmdir /s /q ${venvDir}
        ${pythonExecutable} -m venv ${venvDir}
        call ${venvActivate} && pip install --upgrade pip && pip install -r requirements.txt
    """
}

// =========================================================================
// SECTION 5: COMMAND EXECUTION FUNCTIONS
// =========================================================================
def runPerformanceReport(venvDir) {
    echo "Running Performance Reporter..."
    
    def command = constructCommand(params)
    def pythonAppEnv = [
        "JIRA_USERNAME=${params.USERNAME}",
        "JIRA_PASSWORD=${params.PASSWORD}",
        "BITBUCKET_USERNAME=${params.USERNAME}",
        "BITBUCKET_PASSWORD=${params.PASSWORD}",
    ]
    
    withEnv(pythonAppEnv) {
        runCommandInVenv(venvDir, command)
    }
    
    echo "Executing command: ${command}"
}

def constructCommand(params) {
    def command = "python -m src.app.main report"
    command += " --${params.SOURCE_TYPE}"
    command += params.SOURCE_TYPE == 'jql' ? " ${escapeCommandQuotes(params.SOURCE_IDENTIFIER)}" : " ${params.SOURCE_IDENTIFIER}"
    
    if (params.LATEST_SPRINT) {
        command += " --latest-sprint"
    }
    if (params.START_DATE) {
        command += " --start-date ${params.START_DATE}"
    }
    if (params.END_DATE) {
        command += " --end-date ${params.END_DATE}"
    }
    command += " --format ${params.REPORT_FORMAT ?: 'excel'}"
    command += " --max-workers ${params.MAX_WORKERS ?: '10'}"
    
    return command
}

def escapeCommandQuotes(arg) {
    def escaped = arg.replaceAll("'", "\\\\'").replaceAll('"', '\\\\"')
    return "\"${escaped}\""
}

def runCommandInVenv(venvDir, command) {
    echo "Running command in virtual environment: ${command}"
    def venvActivate = isUnix() ? ". ${venvDir}/bin/activate" : "${venvDir}\\Scripts\\activate"
    
    if (isUnix()) {
        sh "${venvActivate} && ${command}"
    } else {
        bat "${venvActivate} && ${command}"
    }
}

// =========================================================================
// SECTION 6: REPORT ARCHIVING FUNCTIONS
// =========================================================================
def archiveReportArtifacts(reportFileNames) {
    echo "Archiving report artifacts..."
    def reportFiles = reportFileNames.collect { fileName -> "${fileName}" }.join(' ')
    archiveArtifacts artifacts: reportFiles, allowEmptyArchive: true
    echo "Archived report files: ${reportFiles}"
}

// =========================================================================
// SECTION 7: ERROR HANDLING AND CLEANUP
// =========================================================================
def handleError(Exception e) {
    echo "An error occurred during the pipeline execution: ${e.message}"
    throw e
}

def cleanup(venvDir) {
    stage('Cleanup') {
        echo "Cleaning up workspace..."
        cleanWs()
        echo "Removing virtual environment: ${venvDir}"
        // Uncomment to clean up virtual environment
        if (isUnix()) {
            sh "rm -rf ${venvDir}"
        } else {
            bat "if exist ${venvDir} ( rmdir /s /q ${venvDir} )"
        }
    }
}