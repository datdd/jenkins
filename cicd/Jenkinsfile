// Jenkinsfile (Scripted Pipeline)

// =========================================================================
// SECTION 1: PROPERTIES (Includes Parameters)
// This block must be at the top level of the script. It defines the
// parameters for the "Build with Parameters" screen.
// =========================================================================
properties([
    parameters([
        string(name: 'JIRA_AUTH_USERNAME', defaultValue: '...', description: 'Jira username'),
        password(name: 'JIRA_AUTH_PASSWORD', defaultValue: '', description: 'Jira password'),
        choice(
            name: 'SOURCE_TYPE',
            choices: ['group', 'project', 'users'],
            description: 'The source for finding users to report on.'
        ),
        string(
            name: 'SOURCE_IDENTIFIER',
            defaultValue: 'developers',
            description: 'The name of the group, project key, or comma-separated list of usernames.'
        ),
        booleanParam(
            name: 'LATEST_SPRINT',
            defaultValue: false,
            description: 'Check this to generate the report for each user\'s individual latest completed sprint.'
        ),
        string(
            name: 'START_DATE',
            defaultValue: '',
            description: 'Start date (YYYY-MM-DD). Leave empty if using --latest-sprint without date override.'
        ),
        string(
            name: 'END_DATE',
            defaultValue: '',
            description: 'End date (YYYY-MM-DD). Leave empty if using --latest-sprint without date override.'
        ),
        choice(
            name: 'REPORT_FORMAT',
            choices: ['excel', 'csv', 'console'],
            description: 'The output format for the report.'
        ),
        string(
            name: 'MAX_WORKERS',
            defaultValue: '10',
            description: 'Maximum number of parallel worker threads for API calls.'
        )
    ])
])

// The main node block where the build will execute
node {
    // Define variables for the script
    def venvDir = "venv"
    

    // =========================================================================
    // SECTION 2: MAIN EXECUTION (try/finally for cleanup)
    // The try/finally block ensures that the cleanup stage always runs.
    // =========================================================================
    try {
        // --- STAGE: Setup Environment ---
        stage('Setup Environment') {
            echo "Setting up Python virtual environment..."
            checkout scm
            if (isUnix()) {
                echo "Running on Unix..."
                def pythonExecutable = "python3"
                def venvActivate = ". ${venvDir}/bin/activate"
                
                sh "${pythonExecutable} --version"
                sh "rm -rf ${venvDir}"
                sh "${pythonExecutable} -m venv ${venvDir}"
                sh "${venvActivate} && pip install --upgrade pip && pip install -r requirements.txt"
            } else {
                echo "Running on Windows..."
                def pythonExecutable = "py -3"
                def venvActivate = "${venvDir}\\Scripts\\activate"
                
                bat "${pythonExecutable} --version"
                bat "if exist ${venvDir} ( rmdir /s /q ${venvDir} )"
                bat "${pythonExecutable} -m venv ${venvDir}"
                bat "${venvActivate} && pip install --upgrade pip && pip install -r requirements.txt"
            }
        }

        // --- STAGE: Run Performance Reporter ---
        stage('Run Performance Reporter') {
            echo "Constructing report command..."
            
            // --- Build the command dynamically using Groovy ---
            def command = "python -m src.app.main"
            command += " --${params.SOURCE_TYPE} \"${params.SOURCE_IDENTIFIER}\""
            
            if (params.LATEST_SPRINT) {
                command += " --latest-sprint"
            }
            if (params.START_DATE) {
                command += " --start-date ${params.START_DATE}"
            }
            if (params.END_DATE) {
                command += " --end-date ${params.END_DATE}"
            }
            command += " --format ${params.REPORT_FORMAT}"
            command += " --max-workers ${params.MAX_WORKERS}"
            
            echo "Executing: ${command}"
            
            // Activate the venv and run the command
            if (isUnix()) {
                def venvActivate = ". ${venvDir}/bin/activate"
                sh "${venvActivate} && ${command}"
            } else {
                def venvActivate = "${venvDir}\\Scripts\\activate"
                bat "${venvActivate} && ${command}"
            }
        }

        // --- STAGE: Archive Report ---
        stage('Archive Report') {
            // This logic runs only if a report file was meant to be created
            if (params.REPORT_FORMAT == 'excel' || params.REPORT_FORMAT == 'csv') {
                def reportFileName = (params.REPORT_FORMAT == 'excel') ? 'performance_report.xlsx' : 'performance_report.csv'
                echo "Archiving generated report: ${reportFileName}"
            } else {
                echo "Skipping archiving as report format is 'console'."
            }
        }
    }
    catch (e) {
        // If any stage fails, this block will be executed
        echo "An error occurred during the pipeline execution."
        // Re-throw the exception to mark the build as failed
        throw e
    }
    finally {
        // --- STAGE: Cleanup ---
        // This stage will run regardless of whether the build succeeded or failed
        stage('Cleanup') {
            echo "Cleaning up workspace..."
            // Remove the virtual environment
            // sh "rm -rf ${VENV_DIR}"
        }
    }
}