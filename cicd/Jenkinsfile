// Jenkinsfile (Scripted Pipeline)

// =========================================================================
// SECTION 1: PROPERTIES (Includes Parameters)
// This block must be at the top level of the script. It defines the
// parameters for the "Build with Parameters" screen.
// =========================================================================
properties([
    parameters([
        choice(
            name: 'SOURCE_TYPE',
            choices: ['group', 'project', 'users'],
            description: 'The source for finding users to report on.'
        ),
        string(
            name: 'SOURCE_IDENTIFIER',
            defaultValue: 'developers',
            description: 'The name of the group, project key, or comma-separated list of usernames.'
        ),
        booleanParam(
            name: 'LATEST_SPRINT',
            defaultValue: false,
            description: 'Check this to generate the report for each user\'s individual latest completed sprint.'
        ),
        string(
            name: 'START_DATE',
            defaultValue: '',
            description: 'Start date (YYYY-MM-DD). Leave empty if using --latest-sprint without date override.'
        ),
        string(
            name: 'END_DATE',
            defaultValue: '',
            description: 'End date (YYYY-MM-DD). Leave empty if using --latest-sprint without date override.'
        ),
        choice(
            name: 'REPORT_FORMAT',
            choices: ['excel', 'csv', 'console'],
            description: 'The output format for the report.'
        ),
        string(
            name: 'MAX_WORKERS',
            defaultValue: '10',
            description: 'Maximum number of parallel worker threads for API calls.'
        )
    ])
])

// The main node block where the build will execute
node {
    // Define variables for the script
    def VENV_DIR = "venv"
    
    // =========================================================================
    // SECTION 2: MAIN EXECUTION (try/finally for cleanup)
    // The try/finally block ensures that the cleanup stage always runs.
    // =========================================================================
    try {
        // --- STAGE: Setup Environment ---
        stage('Setup Environment') {
            echo "Setting up Python virtual environment..."
            
            // Checkout the source code from SCM (e.g., Git)
            checkout scm
            
            // Check if Python is available
            sh 'python3 --version'
            
            // Create a virtual environment to isolate dependencies
            sh "python3 -m venv ${VENV_DIR}"
            
            // Install dependencies from requirements.txt
            sh ". ${VENV_DIR}/bin/activate && pip install --upgrade pip && pip install -r requirements.txt"
        }

        // --- STAGE: Run Performance Reporter ---
        stage('Run Performance Reporter') {
            // Use withCredentials to securely load secrets into environment variables
            // The secrets will be masked in the console log.
            withCredentials([
                string(credentialsId: 'JIRA_API_TOKEN', variable: 'JIRA_API_TOKEN_SECRET'),
                string(credentialsId: 'BITBUCKET_TOKEN', variable: 'BITBUCKET_TOKEN_SECRET')
            ]) {
                // Use withEnv to set all other non-secret environment variables
                withEnv([
                    "JIRA_SERVER=https://your-domain.atlassian.net",
                    "JIRA_USER_EMAIL=your-service-account@example.com",
                    "BITBUCKET_URL=https://bitbucket.your-company.com",
                    "BITBUCKET_USER=your-bitbucket-service-account",
                    // Pass the secrets from withCredentials into the environment
                    "JIRA_API_TOKEN=${JIRA_API_TOKEN_SECRET}",
                    "BITBUCKET_TOKEN=${BITBUCKET_TOKEN_SECRET}",
                    // ... and all other .env variables
                    "JIRA_IS_CLOUD=true",
                    "JIRA_STORY_POINTS_FIELD_ID=customfield_10016",
                    "BITBUCKET_PROJECT_KEYS=PROJ1,PROJ2",
                    "SUPPORT_ISSUE_IDENTIFIERS=SUPPORT,HELPDESK",
                    "MEETINGS_ISSUE_IDENTIFIERS=MEETING",
                    "SPRINT_MOVEMENT_THRESHOLD=3",
                    "TOP_N_TASKS_LIMIT=3"
                ]) {
                    echo "Constructing report command..."
                    
                    // --- Build the command dynamically using Groovy ---
                    def command = "python3 -m src.main report"
                    command += " --${params.SOURCE_TYPE} \"${params.SOURCE_IDENTIFIER}\""
                    
                    if (params.LATEST_SPRINT) {
                        command += " --latest-sprint"
                    }
                    if (params.START_DATE) {
                        command += " --start-date ${params.START_DATE}"
                    }
                    if (params.END_DATE) {
                        command += " --end-date ${params.END_DATE}"
                    }
                    command += " --format ${params.REPORT_FORMAT}"
                    command += " --max-workers ${params.MAX_WORKERS}"
                    
                    echo "Executing: ${command}"
                    
                    // Activate the venv and run the command
                    sh ". ${VENV_DIR}/bin/activate && ${command}"
                }
            }
        }

        // --- STAGE: Archive Report ---
        stage('Archive Report') {
            // This logic runs only if a report file was meant to be created
            if (params.REPORT_FORMAT == 'excel' || params.REPORT_FORMAT == 'csv') {
                def reportFileName = (params.REPORT_FORMAT == 'excel') ? 'performance_report.xlsx' : 'performance_report.csv'
                echo "Archiving generated report: ${reportFileName}"
                
                archiveArtifacts(
                    artifacts: reportFileName,
                    allowEmptyArchive: true
                )
            } else {
                echo "Skipping archiving as report format is 'console'."
            }
        }
    }
    catch (e) {
        // If any stage fails, this block will be executed
        echo "An error occurred during the pipeline execution."
        // Re-throw the exception to mark the build as failed
        throw e
    }
    finally {
        // --- STAGE: Cleanup ---
        // This stage will run regardless of whether the build succeeded or failed
        stage('Cleanup') {
            echo "Cleaning up workspace..."
            // Remove the virtual environment
            sh "rm -rf ${VENV_DIR}"
        }
    }
}